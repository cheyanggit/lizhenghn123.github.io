---
layout: post

title: 面向对象设计之23种设计模式介绍

category: 架构

tags: 开发 技术 设计模式

keywords: 面向对象 设计模式 Gof

description: 本文先简单介绍面向对象设计过程中的23种设计模式，本文参考自GOF名著<<设计模式-可复用面向对象软件的基础（中文版）>>。

---


设计面向对象软件比较困难，而设计可复用的面向对象软件就更加困难。你必须找到相关的对象，以适当的粒度将它们归类，再定义类的接口和继承层次，建立对象之间的基本关系。你的设计应该对手头的问题有针对性，同时对将来的问题和需求也要有足够的通用性。你也希望避免重复设计或尽可能少做重复设计。有经验的面向对象设计者会告诉你，要一下子就得到复用性和灵活性好的设计，即使不是不可能的至少也是非常困难的。一个设计在最终完成之前常要被复用好几次，而且每一次都有所修改。

设计模式使人们可以更加简单方便地复用成功的设计和体系结构。将已证实的技术表述成设计模式也会使新系统开发者更加容易理解其设计思路。设计模式帮助你做出有利于系统复用的选择，避免设计损害了系统复用性。通过提供一个显式类和对象作用关系以及它们之间潜在联系的说明规范，设计模式甚至能够提高已有系统的文档管理和系统维护的有效性。

**简而言之，设计模式可以帮助设计者更快更好地完成系统设计。**

但是，

**1. 设计模式并不是万能的；**

**2. 设计模式很普通，并无神秘之处；**

**3. 设计模式不是具体的技术，更多的是如何让代码更容易阅读、更好扩展、更容易使用;**

<font color= red>
设计模式体现的是一种思想， 而思想则是指导行为的一切， 要理解和掌握设计模式，并不是说记住了 23 种（或更多）设计场景和解决策略就能够设计出更完美的结果， 相反实际接受的是一种思想的熏陶和洗礼， 等这种思想融入到了你的思维中后，你就会不自觉地使用这种思想去进行你的设计和开发，而这才是最重要的。</font>

本系列是对Gof名著<<设计模式-**可复用**面向对象软件的基础（中文版）>>学习并整理而来，原著中论述了23种设计模式，分别是：

- Abstract Factory：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。
- Adapter：将一个类的接口转换成客户希望的另外一个接口。 Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
- Bridge：将抽象部分与它的实现部分分离，使它们都可以独立地变化。
- Builder：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
- Chain of Responsibility：为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。
- Command：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。
- Composite：将对象组合成树形结构以表示“部分 -整体”的层次结构。 Composite使得客户对单个对象和复合对象的使用具有一致性。
- Decorator：动态地给一个对象添加一些额外的职责。就扩展功能而言， Decorator模式比生成子类方式更为灵活。
- Facade：为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
- Factory Method：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。Factory Method使一个类的实例化延迟到其子类。
- Flyweight：运用共享技术有效地支持大量细粒度的对象。
- Interpreter：给定一个语言 , 定义它的文法的一种表示，并定义一个解释器, 该解释器使用该表示来解释语言中的句子。
- Iterator：提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。
- Mediator：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式
地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
- Memento：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。
- Observer：定义对象间的一种一对多的依赖关系 ,以便当一个对象的状态发生改变时,所有依赖于它的对象都得到通知并自动刷新。
- Prototype：用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。
- Proxy：为其他对象提供一个代理以控制对这个对象的访问。
- Singleton：保证一个类仅有一个实例，并提供一个访问它的全局访问点。
- State：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。
- Strategy：定义一系列的算法 ,把它们一个个封装起来 , 并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户。
- Template Method：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
- Visitor：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。

在选择哪种模式的时候，也是有一定章法的，比如可以从设计中的可变部分，通常来说我们要做的就是**封装变化**。下表列出了设计模式允许你独立变化的方面，你可以改变它们而又不会导致重新设计。

![](http://i.imgur.com/sqoYQb4.png)

接下来将分别单独介绍创建型、结构型、行为型设计模式。

## Reference
- <<设计模式-可复用面向对象软件的基础（中文版）>>
